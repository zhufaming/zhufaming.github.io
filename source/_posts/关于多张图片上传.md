---
title: 关于多张图片上传、地址返回顺序问题
catalog: true
date: 2019-01-18 22:29:53
subtitle:
header-img:
tags:
- oc
- 开发技巧
categories:
- OC
---
~~文章是自己简书、Copy过来的，当时反应还不错，估计也是不少开发者关心的问题。记录下来共勉，共同学习~~
[简书](https://www.jianshu.com/u/77d15218620f)
### 先看描述
需求是怎样的：for 循环里面、多个网络请求上传图片，每次上传一张，至于为什么每次只上传一张呢，因为上传一张将要返回图片存储服务器的地址，然后再把地址作为请求参数，请求自己服务器的 API。

### 过程可以说曲折，不过也有收获

#### 解决方案一：
 递归调用上传图片的函数、第一张请求成功后，然后第二张，依次进行。当然效率肯定不高，即使上传图片的AFN方法做了多线程处理。中间上传失败了，还继续上传吗？需求决定。所有放弃

#### 解决方案二：
使用GCD 队列组：这里就直接贴代码了：
```
dispatch_group_t group =  dispatch_group_create();
   for(..){
        dispatch_group_async(group,dispatch_get_global_queue(0, 0), ^{
        NSLog(@"队列组：有一个耗时操作完成！");
        });
      }
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        NSLog(@"队列组：前面的耗时操作都完成了，回到主线程进行相关操作");
    });
```
我只能说想法很完美啊，网上也不只提出这种方案，但是我的实践过程是有问题了。网络请求延迟，队列组不可控。所以放弃

#### 方案三：利用数组的有序性：
怎么个利用法？请看：
1. 创建一个模型、两个属性第一个你要上传的数据信息如：image 或者 data ，根据你上传函数需要的参数来定。第二个属性：NSString  URL  服务端返回的图片地址：

2、将你要上传的图片数组、封装成模型数组，数组是有序的这就是重点，for 循环 模型作为参数调用图片上传函数，请求成功后更新模型的值

3、判断所有的图片上传完毕，然后，就从模型数组里面去取 ，图片 url ，请求自己的服务器api

好了，应该很清楚吧。不清楚再上点干货：

model:
```
// 建立这个类的目的、主要是为了for循环多张图片上传、成功后回来的地址顺序问题

#import <Foundation/Foundation.h>

@interface FMUploadModel : NSObject
//根据自己的上传函数需要决定
@property (nonatomic,strong) NSArray * dataArray;

@property (nonatomic,copy) NSString *imgUrl;

@end

```

function
```
//开辟一个多线程 执行图片上传工作
           dispatch_queue_t queue = dispatch_queue_create("upimgs", DISPATCH_QUEUE_CONCURRENT);

            dispatch_async(queue, ^{
                // 耗时操作放在这里
                
                __weak typeof(self) weakself = self;
                __block int finishNum = 0;
                for (int i = 0 ; i < self.selectImgs.count; i++) {
                    YRFormData *getData = [[YRFormData alloc] init];
                    getData.data = UIImagePNGRepresentation(self.selectImgs[i]);
                    getData.name = @"uzee_image";
                    getData.filename = @"head.png";
                    getData.mimeType = @"image/png";
                    NSArray *array = @[getData];
                    //***********//
                    FMUploadModel *model = [FMUploadModel new];
                    model.dataArray = array;
                    model.imgUrl = @"";
                    [models addObject:model];
                    /*******其实是一张一张传的，传数组是调用这个方法**********/
                    [YRHttpTool postWithURLNoAES:@"*****" params:@{} formDataArray:model.dataArray success:^(id json) {
                        finishNum ++ ;
                        model.imgUrl = json[@"response"][@"cloud"];
                        if (finishNum == self.selectImgs.count) {
                            dispatch_async(dispatch_get_main_queue(), ^{
                                // 回到主线程进行UI操作
                                [MBProgressHUD hideHUDForView:weakself.view];
                                updateImage();
                            });
                            
                        }
                        
                    } failure:^(NSError *error) {
                        dispatch_async(dispatch_get_main_queue(), ^{
                            // 回到主线程进行UI操作
                            [MBProgressHUD hideHUDForView:weakself.view];
                            [MBProgressHUD showError:@"图片上传失败，请稍后再试" toView:self.view];
                        });
                    } progress:^(NSProgress *progress) {
                        [[NSOperationQueue mainQueue] addOperationWithBlock:^{
                            
                            float value = 1.0 *progress.completedUnitCount / progress.totalUnitCount;
                            [MBProgressHUD showDownload:@"发布中..." toView:weakself.view progress:value];
                        }];
                        
                    }];
                    
                    
                }
            });
```


